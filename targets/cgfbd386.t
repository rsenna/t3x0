! T3X/0 back-end for FreeBSD on the 386
! Basically CGUNX386, but with runtime library in assembly language
! Nils M Holm, 2019,2022,2023
! In the Public Domain / 0BSD License

module cg;

 public const	BPW = 4;

 public const	GPOOL_SIZE = 0;

 public const	BUFLEN = 512;

 public const	SYMTBL_SIZE = 2048;
 public const	LABEL_SIZE = 4096;
 public const	NLIST_SIZE = 6144;

 public const	LOCAL_LIMIT = 32760;

 public binary() return 0;

 public suffix() return ".s";

 public modpath() return [
	"/usr/local/t3x/0/fbd386/",
	"",
	"library/",
	"/usr/local/t3x/0/",
	0 ];

 public header() do
	return 0;
 end

 public textseg() return ".text\n";
 public dataseg() return ".data\n";
 public defbyte() return ".byte ";
 public defword() return ".long ";
 public defaddr() return ".long L";
 public defglob() return ".long 0\n";

 public codefrags() return [
	[ CG_NULL,	[0]			],
	[ CG_PUSH,	["push %eax",0]		],
	[ CG_CLEAR,	["xor %eax,%eax",0]	],
	[ CG_DROP,	["pop %ebx",0]		],
	[ CG_LDVAL,	["mov $!w,%eax",0]	],
	[ CG_LDADDR,	["mov $L!w,%eax",0]	],
	[ CG_LDLREF,	["lea !w(%ebp),%eax",0]	],
	[ CG_LDGLOB,	["mov L!w,%eax",0]	],
	[ CG_LDLOCL,	["mov !w(%ebp),%eax",0]	],
	[ CG_STGLOB,	["mov %eax,L!w",0]	],
	[ CG_STLOCL,	["mov %eax,!w(%ebp)",0]	],
	[ CG_STINDR,	["pop %ebx",
			 "mov %eax,(%ebx)",0]	],
	[ CG_STINDB,	["pop %ebx",
			 "mov %al,(%ebx)",0]	],
	[ CG_INCGLOB,	["incl L!w",0]		],
	[ CG_INCLOCL,	["incl !w(%ebp)",0]	],
	[ CG_INCR,	["add $!w,%eax",0]	],
	[ CG_STACK,	["add $!w,%esp",0]	],
	[ CG_UNSTACK,	["add $!w,%esp",0]	],
	[ CG_LOCLVEC,	["mov %esp,%eax",
			 "push %eax",0]		],
	[ CG_GLOBVEC,	["mov %esp,L!w",0]	],
	[ CG_INDEX,	["shl $2,%eax",
			 "pop %ebx",
			 "add %ebx,%eax",0]	],
	[ CG_DEREF,	["mov (%eax),%eax",0]	],
	[ CG_INDXB,	["pop %ebx",
			 "add %ebx,%eax",0]	],
	[ CG_DREFB,	["mov %eax,%ebx",
			 "xor %eax,%eax",
			 "mov (%ebx),%al",0]	],
	[ CG_CALL,	["call L!w",0]		],
	[ CG_CALR,	["call *%eax",0]	],
	[ CG_JUMP,	["jmp L!w",0]		],
	[ CG_RJUMP,	["jmp L!w",0]		],
	[ CG_JMPFALSE,	["or %eax,%eax",
			 "jz L!w",0]		],
	[ CG_JMPTRUE,	["or %eax,%eax",
			 "jnz L!w",0]		],
	[ CG_FOR,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jge L!w",0]		],
	[ CG_FORDOWN,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jle L!w",0]		],
	[ CG_MKFRAME,	["push %ebp",
			 "mov %esp,%ebp",0]	],
	[ CG_DELFRAME,	["pop %ebp",0]		],
	[ CG_RET,	["ret",0]		],
	[ CG_HALT,	["push $!w",
			 "pushl $0",
			 "mov $1,%eax",
			 "int $0x80",0]		],
	[ CG_NEG,	["neg %eax",0]		],
	[ CG_INV,	["not %eax",0]		],
	[ CG_LOGNOT,	["neg %eax",
			 "sbb %eax,%eax",
			 "not %eax",0]		],
	[ CG_ADD,	["pop %ebx",
			 "add %ebx,%eax",0]	],
	[ CG_SUB,	["mov %eax,%ebx",
			 "pop %eax",
			 "sub %ebx,%eax",0]	],
	[ CG_MUL,	["pop %ecx",
			 "imul %ecx",0]		],
	[ CG_DIV,	["mov %eax,%ecx",
			 "pop %eax",
			 "cltd",
			 "idiv %ecx",0]		],
	[ CG_MOD,	["mov %eax,%ecx",
			 "pop %eax",
			 "xor %edx,%edx",
			 "div %ecx",
			 "mov %edx,%eax",0]	],
	[ CG_AND,	["pop %ebx",
			 "and %ebx,%eax",0]	],
	[ CG_OR,	["pop %ebx",
			 "or %ebx,%eax",0]	],
	[ CG_XOR,	["pop %ebx",
			 "xor %ebx,%eax",0]	],
	[ CG_SHL,	["mov %eax,%ecx",
			 "pop %eax",
			 "shl %cl,%eax",0]	],
	[ CG_SHR,	["mov %eax,%ecx",
			 "pop %eax",
			 "shr %cl,%eax",0]	],
	[ CG_EQ,	["pop %ebx",
			 "cmp %ebx,%eax",
			 "setne %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_NE,	["pop %ebx",
			 "cmp %ebx,%eax",
			 "sete %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_LT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "setge %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_GT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "setle %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_LE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "setg %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_GE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "setl %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_UMUL,	["pop %ecx",
			 "mul %ecx",0]		],
	[ CG_UDIV,	["mov %eax,%ecx",
			 "pop %eax",
			 "xor %edx,%edx",
			 "div %ecx",0]		],
	[ CG_ULT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "setae %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_UGT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "setbe %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_ULE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "seta %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_UGE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "setb %dl",
			 "movzbl %dl,%eax",
			 "dec %eax",0]		],
	[ CG_JMPEQ,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "je L!w",0]		],
	[ CG_JMPNE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jne L!w",0]		],
	[ CG_JMPLT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jl L!w",0]		],
	[ CG_JMPGT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jg L!w",0]		],
	[ CG_JMPLE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jle L!w",0]		],
	[ CG_JMPGE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jge L!w",0]		],
	[ CG_JMPULT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jb L!w",0]		],
	[ CG_JMPUGT,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "ja L!w",0]		],
	[ CG_JMPULE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jbe L!w",0]		],
	[ CG_JMPUGE,	["pop %ebx",
			 "cmp %eax,%ebx",
			 "jae L!w",0]		],
	[ CG_SKIP,	["jmp L!w",0]		],
	[ CG_CALN,	["call t3x_!n",0]	],
	[ CG_LDNAM,	["mov $t3x_!n,%eax",0]	],
	[ %1,		[0]			] ];

 public optimizations() return [
	[ CG_EQ,	0,	CG_JMPFALSE,	CG_JMPNE	],
	[ CG_NE,	0,	CG_JMPFALSE,	CG_JMPEQ	],
	[ CG_LT,	0,	CG_JMPFALSE,	CG_JMPGE	],
	[ CG_GT,	0,	CG_JMPFALSE,	CG_JMPLE	],
	[ CG_LE,	0,	CG_JMPFALSE,	CG_JMPGT	],
	[ CG_GE,	0,	CG_JMPFALSE,	CG_JMPLT	],
	[ CG_EQ,	0,	CG_JMPTRUE,	CG_JMPEQ	],
	[ CG_NE,	0,	CG_JMPTRUE,	CG_JMPNE	],
	[ CG_LT,	0,	CG_JMPTRUE,	CG_JMPLT	],
	[ CG_GT,	0,	CG_JMPTRUE,	CG_JMPGT	],
	[ CG_LE,	0,	CG_JMPTRUE,	CG_JMPLE	],
	[ CG_GE,	0,	CG_JMPTRUE,	CG_JMPGE	],
	[ CG_LOGNOT,	0,	CG_JMPFALSE,	CG_JMPTRUE	],
	[ CG_DROP,	0,	CG_PUSH,	CG_NULL		],
	[ %1,		%1,	%1,		%1		],
	[ CG_LDVAL,	0,	CG_INDEX,	CG_DROP		],
	[ CG_LDVAL,	0,	CG_INDXB,	CG_DROP		],
	[ CG_LDVAL,	0,	CG_ADD,		CG_DROP		],
	%1 ];

 public library() return [ [
	"	.data",
	"args:	.long	0",
	"",
	"	.text",
	"	.globl	_start",
	"_start:	lea	4(%esp),%eax",
	"	mov	%eax,args",
	"	jmp	start",
	"",
	"syscall:",
	"	int	$0x80",
	"	ret",
	"",
	"# t3x.bpw()",
	"",
	"t3x_bpw:",
	"	mov	$4,%eax",
	"	ret",
	"",
	"# t3x.newline(buf)",
	"",
	"t3x_newline:",
	"	mov	4(%esp),%esi",
	"	mov	$10,%al",
	"	mov	%al,(%esi)",
	"	inc	%esi",
	"	xor	%eax,%eax",
	"	mov	%al,(%esi)",
	"	mov	4(%esp),%eax",
	"	ret",
	"",
	"# t3x.memcopy(d, s, n)",
	"",
	"t3x_memcopy:",
	"	push	%ebp",
	"	mov	%esp,%ebp",
	"	mov	16(%ebp),%edi",
	"	mov	12(%ebp),%esi",
	"	mov	8(%ebp),%ecx",
	"	cld",
	"	cmp	%esi,%edi",
	"	jz	endmcp",
	"	jb	domc",
	"	std",
	"	add	%ecx,%esi",
	"	add	%ecx,%edi",
	"	dec	%esi",
	"	dec	%edi",
	"domc:	rep movsb",
	"endmcp:	pop	%ebp",
	"	ret",
	"",
	"# t3x.memcomp",
	"",
	"t3x_memcomp:",
	"	push	%ebp",
	"	mov	%esp,%ebp",
	"	mov	16(%ebp),%edi",
	"	mov	12(%ebp),%esi",
	"	mov	8(%ebp),%ecx",
	"	cmp	%esi,%edi",
	"	jnz	domcm",
	"mc0:	xor	%eax,%eax",
	"	jmp	endmcm",
	"domcm:	inc	%ecx",
	"	cld",
	"	repz cmpsb",
	"	or	%ecx,%ecx",
	"	jz	mc0",
	"	xor	%eax,%eax",
	"	mov	-1(%edi),%al",
	"	xor	%ebx,%ebx",
	"	mov	-1(%esi),%bl",
	"	sub	%ebx,%eax",
	"endmcm:	pop	%ebp",
	"	ret",
	"",
	"# t3x.memfill(d, c, n)",
	"",
	"t3x_memfill:",
	"	push	%ebp",
	"	mov	%esp,%ebp",
	"	mov	16(%ebp),%edi",
	"	mov	12(%ebp),%eax",
	"	mov	8(%ebp),%ecx",
	"	cld",
	"	rep stosb",
	"	xor	%eax,%eax",
	"	pop	%ebp",
	"	ret",
	"",
	"# t3x.memscan(s, c, n)",
	"",
	"t3x_memscan:",
	"	push	%ebp",
	"	mov	%esp,%ebp",
	"	mov	16(%ebp),%edi",
	"	mov	12(%ebp),%eax",
	"	mov	8(%ebp),%ecx",
	"	mov	%edi,%edx",
	"	inc	%ecx",
	"	cld",
	"	repnz scasb",
	"	or	%ecx,%ecx",
	"	jz	msc0",
	"	mov	%edi,%eax",
	"	sub	%edx,%eax",
	"	jmp	endmsc",
	"msc0:	xor	%eax,%eax",
	"endmsc:	dec	%eax",
	"	pop	%ebp",
	"	ret",
	"",
	"# t3x.getarg(n, b, k)",
	"",
	"t3x_getarg:",
	"	push	%ebp",
	"	mov	%esp,%ebp",
	"	mov	16(%ebp),%ecx",
	"	mov	args,%esi",
	"nxtarg:	mov	(%esi),%eax",
	"	or	%eax,%eax",
	"	jz	noarg",
	"	or	%ecx,%ecx",
	"	jz	getarg",
	"	dec	%ecx", 0 ], [
	"	add	$4,%esi",
	"	jmp	nxtarg",
	"getarg:	mov	(%esi),%esi",
	"	mov	12(%ebp),%edi",
	"	mov	8(%ebp),%ecx",
	"	xor	%ebx,%ebx",
	"getnc:	dec	%ecx",
	"	jz	endma",
	"	mov	(%esi),%al",
	"	or	%al,%al",
	"	jz	endma",
	"	mov	%al,(%edi)",
	"	inc	%esi",
	"	inc	%edi",
	"	inc	%ebx",
	"	jmp	getnc",
	"endma:	xor	%eax,%eax",
	"	mov	%al,(%edi)",
	"	mov	%ebx,%eax",
	"	jmp	endarg",
	"noarg:	xor	%eax,%eax",
	"	dec	%eax",
	"endarg:	pop	%ebp",
	"	ret",
	"",
	"# t3x.create(path)",
	"",
	"t3x_create:",
	"	push	$0644		# mode",
	"	push	$0x601		# O_CREAT | O_TRUNC | O_WRONLY",
	"	push	12(%esp)	# path",
	"	mov	$5,%eax		# open",
	"	call	syscall",
	"	jnc	crtok",
	"	neg	%eax",
	"crtok:	add	$12,%esp",
	"	ret",
	"",
	"# t3x.open(path, flags);",
	"",
	"t3x_open:",
	"	mov	4(%esp),%eax	# flags",
	"	cmp	$1,%eax",
	"	jnz	open1",
	"	push	8(%esp)		# path",
	"	call	t3x_create",
	"	add	$4,%esp",
	"	ret",
	"open1:	cmp	$3,%eax",
	"	jnz	open2",
	"	push	$1",
	"	push	12(%esp)",
	"	mov	$5,%eax		# open",
	"	call	syscall",
	"	jnc	opnok1",
	"	neg	%eax",
	"	add	$8,%esp",
	"	ret",
	"opnok1:	add	$8,%esp",
	"	push	$2",
	"	xor	%ebx,%ebx",
	"	push	%ebx",
	"	push	%ebx",
	"	push	%eax",
	"	mov	$478,%eax	# lseek",
	"	call	syscall",
	"	jnc	opnok2",
	"	neg	%eax",
	"opnok2:	add	$16,%esp",
	"	ret",
	"open2:	push	4(%esp)		# flags",
	"	push	12(%esp)	# path",
	"	mov	$5,%eax		# open",
	"	call	syscall",
	"	jnc	opnok3",
	"	neg	%eax",
	"opnok3:	add	$8,%esp",
	"	ret",
	"",
	"# t3x.read(fd, buf, len);",
	"",
	"t3x_read:",
	"	push	4(%esp)		# len",
	"	push	12(%esp)	# buf",
	"	push	20(%esp)	# fd",
	"	mov	$3,%eax		# read",
	"	call	syscall",
	"	jnc	reaok",
	"	neg	%eax",
	"reaok:	add	$12,%esp",
	"	ret",
	"",
	"# t3x.write(fd, buf, len);",
	"",
	"t3x_write:",
	"	push	4(%esp)		# len",
	"	push	12(%esp)	# buf",
	"	push	20(%esp)	# fd",
	"	mov	$4,%eax		# write",
	"	call	syscall",
	"	jnc	wrtok",
	"	neg	%eax",
	"wrtok:	add	$12,%esp",
	"	ret",
	"",
	"# t3x.seek(int fd, int pos, int how);",
	"",
	"t3x_seek:",
	"	mov	4(%esp),%ebx	# how",
	"	mov	8(%esp),%eax	# pos",
	"	cdq",
	"	or	%ebx,%ebx",
	"	jz	seek1",
	"	cmp	$1,%ebx",
	"	jz	seek1",
	"	or	%eax,%eax",
	"	jz	noneg",
	"	neg	%eax",
	"	dec	%edx",
	"noneg:	cmp	$2,%ebx",
	"	jz	seek1",
	"	cmp	$3,%ebx",
	"	jz	seek2",
	"	xor	%eax,%eax",
	"	dec	%eax",
	"	ret",
	"seek2:	mov	$1,%ebx", 0 ], [
	"seek1: push	%ebx",
	"	push	%edx		# offset, high word",
	"	push	%eax		# offset, low word",
	"	push	24(%esp)	# fd",
	"	mov	$478,%eax	# lseek",
	"	call	syscall",
	"	jnc	lseok",
	"	neg	%eax",
	"lseok:	add	$16,%esp",
	"	ret",
	"",
	"# t3x.close(fd);",
	"",
	"t3x_close:",
	"	push	4(%esp)		# fd",
	"	mov	$6,%eax		# close",
	"	call	syscall",
	"	jnc	clsok",
	"	neg	%eax",
	"clsok:	add	$4,%esp",
	"	ret",
	"",
	"# t3x.remove(path);",
	"",
	"t3x_remove:",
	"	push	4(%esp)		# path",
	"	mov	$10,%eax	# unlink",
	"	call	syscall",
	"	jnc	rmvok",
	"	neg	%eax",
	"rmvok:	add	$4,%esp",
	"	ret",
	"",
	"# t3x.rename(old, new);",
	"",
	"t3x_rename:",
	"	push	4(%esp)		# new",
	"	push	12(%esp)	# old",
	"	mov	$128,%eax	# rename",
	"	call	syscall",
	"	jnc	renok",
	"	neg	%eax",
	"renok:	add	$8,%esp",
	"	ret",
	"",
	"# t3x.trunc(fd);",
	"",
	"t3x_trunc:",
	"	mov	4(%esp),%ebx	# fd",
	"	push	$1",
	"	xor	%eax,%eax",
	"	push	%eax",
	"	push	%eax",
	"	push	%ebx",
	"	mov	$478,%eax	# lseek",
	"	call	syscall",
	"	jnc	trcok1",
	"	neg	%eax",
	"	add	$16,%esp",
	"	ret",
	"trcok1:	add	$16,%esp",
	"	mov	4(%esp),%ebx	# fd",
	"	push	%edx",
	"	push	%eax",
	"	push	%ebx",
	"	mov	$480,%eax	# ftruncate",
	"	call	syscall",
	"	jnc	trc2ok",
	"	neg	%eax",
	"trc2ok:	add	$12,%esp",
	"	ret",
	"",
	"start:", 0 ],
	0 ];

end
